Инкремент 23
Задание для трека «Сервис сокращения URL»
Добавьте в сервер новый эндпоинт GET /api/internal/stats, возвращающий в ответ объект:
{
  "urls": <int>, // количество сокращённых URL в сервисе
  "users": <int> // количество пользователей в сервисе
}
Добавьте в конфигурационный JSON-файл HTTP-сервера поле trusted_subnet
(тип string, переменная окружения TRUSTED_SUBNET, флаг -t),
в которое можно передать строковое представление бесклассовой адресации (CIDR).

При запросе эндпоинта /api/internal/stats нужно проверять,
 что переданный в заголовке запроса X-Real-IP IP-адрес клиента входит в доверенную подсеть,
  в противном случае возвращать статус ответа 403 Forbidden.

При пустом значении переменной trusted_subnet доступ к эндпоинту должен быть
 запрещён для любого входящего запроса.
 -------------------------------------------------------------------------------------------------
 Теория:

 IP-адрес запроса
 Разберём практический пример работы с IP-адресами. Допустим, HTTP-сервер должен знать адрес клиента,
  сделавшего запрос.
 Адрес доступен в поле структуры запроса Request.RemoteAddr из пакета net/http.
  Но есть проблема: если между пользователем и Go-приложением стоит HTTP-прокси,
  например nginx или envoy, то в этом поле получим адрес прокси, а не пользователя.
 Чтобы решить эту проблему, прокси-серверы нужно донастроить так, чтобы они прикладывали
 HTTP-заголовок к изначальному IP-адресу пользователя.
 Такой HTTP-заголовок обычно называют X-Real-IP, X-False-IP или X-Forwarded-For.
 Значение заголовка можно получить методом Request.Header.Get.
 Приложение может быть доступно напрямую из сети или через прокси.
 Поэтому в коде программируют оба варианта получения IP пользователя и
 в конфигурацию добавляют параметр, откуда этот IP можно получать: либо из запроса, либо из HTTP-заголовка.

 Напишем пример:

 package main

 import (
     "flag"
     "fmt"
     "net"
     "net/http"
     "strings"
 )

 var (
     bindAddr             = flag.String("bind_addr", ":8080", "")
     resolveIPUsingHeader = flag.Bool("resolve_ip_using_header", false, "")
 )

 func main() {
     flag.Parse()

     s := server{bindAddr: *bindAddr, resolveIPUsingHeader: *resolveIPUsingHeader}
     s.ListenAndServe()
 }

 type server struct {
     bindAddr             string
     resolveIPUsingHeader bool
 }

 func (s *server) ListenAndServe() {
     http.Handle("/get_ip", http.HandlerFunc(s.handleRequest))
     http.ListenAndServe(s.bindAddr, nil)
 }

 func (s *server) handleRequest(w http.ResponseWriter, r *http.Request) {
     ip, err := resolveIP(r, resolveIPOpts{UseHeader: s.resolveIPUsingHeader})
     if err != nil {
         w.WriteHeader(400)
         w.Write([]byte(err.Error()))
     }
     w.WriteHeader(200)
     w.Write([]byte(ip))
 }

 type resolveIPOpts struct {
     UseHeader bool
 }

 func resolveIP(r *http.Request, opts resolveIPOpts) (net.IP, error) {
     if !opts.UseHeader {
         addr := r.RemoteAddr
         // метод возвращает адрес в формате host:port
         // нужна только подстрока host
         ipStr, _, err := net.SplitHostPort(addr)
         if err != nil {
             return nil, err
         }
         // парсим ip
         ip := net.ParseIP(ipStr)
         if ip == nil {
             panic("unexpected parse ip error")
         }
         return ip, nil
     } else {
         // смотрим заголовок запроса X-Real-IP
         ipStr := r.Header.Get("X-Real-IP")
         // парсим ip
         ip := net.ParseIP(ipStr)
         if ip == nil {
             // если заголовок X-Real-IP пуст, пробуем X-Forwarded-For
             // этот заголовок содержит адреса отправителя и промежуточных прокси
             // в виде 203.0.113.195, 70.41.3.18, 150.172.238.178
             ips := r.Header.Get("X-Forwarded-For")
             // разделяем цепочку адресов
             ipStrs := strings.Split(ips, ",")
             // интересует только первый
             ipStr = ipStrs[0]
             // парсим
             ip = net.ParseIP(ipStr)
         }
         if ip == nil {
             return nil, fmt.Errorf("failed parse ip from http header")
         }
         return ip, nil
     }
 }

 Дополнительные материалы
https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For#security_and_privacy_concerns
https://adam-p.ca/blog/2022/03/x-forwarded-for/
http://nginx.org/en/docs/http/ngx_http_realip_module.html
https://github.com/golang/go/blob/161874da2ab6d5372043a1f3938a81a19d1165ad/src/net/conf.go#L122-L280